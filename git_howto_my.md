# Подсказка по GIT
## Что такое Git и зачем он нужен?
**Git** - это консольная утилита, для отслеживания и ведения истории изменения файлов, в вашем проекте. Чаще всего его используют для кода, но можно и для других файлов. Например, для картинок - полезно для дизайнеров.

С помощью Git-a вы можете откатить свой проект до более старой версии, сравнивать, анализировать или сливать свои изменения в репозиторий.

**Репозиторием** называют хранилище вашего кода и историю его изменений. Git работает локально и все ваши репозитории хранятся в определенных папках на жестком диске.

Каждая точка сохранения вашего проекта носит название **коммит (commit)**. У каждого commit-a есть **hash (уникальный id) и комментарий**. Из таких commit-ов собирается ветка. **Ветка** - это история изменений. У каждой ветки есть свое название. Репозиторий может содержать в себе несколько веток, которые создаются из других веток или вливаются в них.

## Создание репозитория:
Создадим наш первый репозиторий. Для этого пройдите в папку вашего проекта.
```sh
#Для Linux и MacOS путь может выглядеть так /Users/UserName/Desktop/MyProject
#Для Windows например С://MyProject
cd <путь_к_вашему_проекту>

#Инициализация/создание репозитория
git init
```
Теперь Git отслеживает изменения файлов вашего проекта. Но, так как вы только создали репозиторий в нем нет вашего кода. Для этого необходимо создать commit.
```sh
#Добавим все файлы проекта в нам будующий commit
git add .
#Или так
git add --all

#Если хотим добавить конкретный файл то можно так
git add <имя_файла> 

#Теперь создаем commit. Обязательно указываем комментарий.
#И не забываем про кавычки
git commit -m "<комментарий text>"
```
Отлично. Вы создали свой первый репозиторий и заполнили его первым commit.
## Процесс работы с Git
Не стоит после каждого изменения файла делать commit. Чаще всего их создают, когда:

* Создан новый функционал
* Добавлен новый блок на верстке
* Исправлены ошибки по коду
* Вы завершили рабочий день и хотите сохранить код

Это поможет держать вашу ветки в чистоте и порядке. Тем самым, вы будете видеть историю изменений по каждому нововведению в вашем проекте, а не по каждому файлу.

## Вспомогательные команды
Просмотр историю ветки:
```sh
git log
```
Просмотр истории ветки в одной линии:
```sh
git log --oneline
```
Переключаться между ветками можно такой командой:
```sh
git checkout <имя_ветки>
```
Для того чтобы посмотреть текущее состояние ветки, например, какие файлы добавлены или не добавлены для создания commit, можно выполнить команду:
```sh
git status
```
Просмотреть изменения относительно двух веток можно командой:
```sh
git diff <исходная_ветка> <целевая_ветка>
```
Удалить ненужную ветку:
```sh
git branch -d <название_ветки>
```
Подсказки по популярным командам:
```sh
# По популярным командам
git help

# Или по конкретной команде
git help <навание_команды>

# Например clone
git help clone
```

Отображение всех веток
```sh
git branch
```

Создание новой ветки 
```sh
git branch <имя_ветки>
```

## Дополнительный функционал

### Клонирование существующего репозитория

Если проект уже настроен в центральном репозитории, наиболее распространенным способом создать его локальный клон является команда **clone**. Клонирование, как и команда **git init**, обычно выполняется один раз. Получив рабочую копию, разработчик в дальнейшем выполняет все операции контроля версий из своего локального репозитория.
```sh
git clone <URL-адрес репозитория>
```
Команду **git clone** выполняют для создания копии (клонирования) удаленного репозитория. В качестве параметра в команду **git clone** передается URL-адрес репозитория.

### Совместная работа в разных репозиториях: git push

#### Введение
Команда **Git push** позволяет отправлять локальную ветку на удаленный репозиторий. Она помогает разработчикам синхронизироваться в команде, а именно отправляет проделанные изменения. Если программист работает один, то пуш позволяет хранить код в облаке, например **github, gitlab** и не только, избавляя от риска потери данных на компьютере.

Дополнительно для синхронизации еще используют **git pull** для получения изменений с сервера и **git remote**, чтобы получить список удаленных подключений к репозиторию.

#### Отправка изменений в чистый репозиторий
Перед пушем надо связать локальный и удаленный репозитории. Делается это при помощи команды:
```sh
git remote add <repository_name> link
```
Вместо **repository_name** нужно дать имя удаленному репозиторию. Далее в инструкции вместо этого параметра мы будем использовать **origin**, так как чаще всего используют это имя.

Вместо **link** — ссылка на удаленный репозиторий, она может выглядеть по-разному в зависимости от того используется **ssh** или **https**. 

#### Отправка изменений
Перед пушем надо зафиксировать текущие изменения, то есть сделать **git commit**.

Далее для отправки в терминале пишем:
```sh
git push origin <branch> 
```
Вместо **branch** — имя ветки, которую надо отправить. Чаще всего используется **master** или **main**: 
```sh
git push origin master
``` 
Такое каждый раз писать слишком громоздко, для этого придумали **git push** по умолчанию. Для этого единожды набираем предыдущую команду с флагом **-u**:
```sh
git push -u origin master
```
После этого можно писать более коротко, так как **git** запомнил, что пушить надо на сервер **origin** ветку под именем **master**:
```sh
git push
```
Таким образом, **git** позволяет запушить ветку в удаленный репозиторий. Чтобы через **git** добавить ветку в удаленный репозиторий, надо запушить существующую локальную ветку.

### Конфигурирование и настройка: git config

Команда **git config** — это удобная функция, которая используется для настройки значений конфигурации **Git** на глобальном и локальном уровнях проекта. Эти уровни конфигурации соответствуют текстовым файлам **.gitconfi**g . При выполнении команды **git config** происходит изменение текстового файла конфигурации.
#### Использование
Самый простой пример использования **git config** — вызов этой команды с именем конфигурации. При этом отобразится заданное для этого имени значение. Имена конфигурации представляют собой строку, состоящую из иерархической последовательности «раздела» и «ключа», разделенных точкой. Пример: **user.email**
```sh
git config user.email
```
В этом примере **«email»** является дочерним свойством блока конфигурации **«user»**. Команда вернет адрес электронной почты (если таковой был указан), который **Git** свяжет с локально созданными коммитами.

### Игнорирование в Git
**Git** рассматривает каждый файл в вашей рабочей копии как файл одного из трех нижеуказанных типов.

1. **Отслеживаемый файл** — файл, который был предварительно проиндексирован или зафиксирован в коммите.

2. **Неотслеживаемый файл** — файл, который не был проиндексирован или зафиксирован в коммите.

3. **Игнорируемый файл** — файл, явным образом помеченный для Git как файл, который необходимо игнорировать.

**Игнорируемые файлы** — это, как правило, артефакты сборки и файлы, генерируемые машиной из исходных файлов в вашем репозитории, либо файлы, которые по какой-либо иной причине не должны попадать в коммиты. Вот некоторые распространенные примеры таких файлов:

* кэши зависимостей, например содержимое /node_modules или /packages;
* скомпилированный код, например файлы .o, .pyc и .class ;
* каталоги для выходных данных сборки, например /bin, /out или /target;
* файлы, сгенерированные во время выполнения, например .log, .lock или .tmp;
* скрытые системные файлы, например .DS_Store или Thumbs.db;
* личные файлы конфигурации IDE, например .idea/workspace.xml.

Игнорируемые файлы отслеживаются в специальном файле **.gitignore**, который регистрируется в корневом каталоге репозитория. В Git нет специальной команды для указания игнорируемых файлов: вместо этого необходимо вручную отредактировать файл **.gitignore**, чтобы указать в нем новые файлы, которые должны быть проигнорированы. Файлы **.gitignore** содержат шаблоны, которые сопоставляются с именами файлов в репозитории для определения необходимости игнорировать эти файлы.

### Создание тегов

**Теги** — это ссылки, указывающие на определенные точки в истории **Git**. Команда **git tag** обычно используется для захвата некой точки в истории, которая используется для релиза нумерованной версии (например, v1.0.1).

Теги похожи на неизменяемые ветки, но они, в отличие от веток, не имеют истории коммитов после создания.
#### Создание тега
Для создания нового тега выполните следующую команду:
```sh
git tag <tagname>
```
Замените **< имя_тега >** семантическим идентификатором состояния репозитория на момент создания тега. Стандартный шаблон для указания номеров версий выглядит как **git tag v1.4**. Git поддерживает два типа тегов: аннотируемые и облегченные. В предыдущем примере был создан облегченный тег. Облегченные и аннотируемые теги отличаются объемом хранящихся в них сопутствующих метаданных. Рекомендуется рассматривать аннотируемые теги как открытые, а облегченные — как закрытые. В аннотируемых тегах хранятся дополнительные метаданные, такие как имя создателя тега, адрес электронной почты и дата. Это важные данные для версии общего пользования. Облегченные теги по сути являются «закладками» для коммитов. Это просто имя и указатель на коммит, что удобно для создания быстрых ссылок на соответствующие коммиты.